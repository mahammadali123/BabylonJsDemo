<!DOCTYPE html>
<html>
<head>
	<title>BabylonJs Demo</title>
	<script src="https://cdn.babylonjs.com/babylon.max.js"></script>
	
	<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script>
	<style type="text/css">
	#canvas{
		width: 100%;
		height: 100%;
	}
		
	</style>
	<script>
	  
      window.addEventListener('DOMContentLoaded', function(){
          var canvas = document.getElementById('canvas');
          var engine = new BABYLON.Engine(canvas, true);
          var createScene = function(){
          	  engine.enableOfflineSupport = false;
              var scene = new BABYLON.Scene(engine);
              const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,10, 2));
              const groundMat = new BABYLON.StandardMaterial("groundMat");
    		  groundMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
    		  const boxMat=new BABYLON.StandardMaterial("boxMat");
    		  boxMat.diffuseColor=new BABYLON.Color3(1,1,1);
    		  boxMat.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png")
    		  var mat = new BABYLON.StandardMaterial("bricks");
			  mat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/bricktile.jpg");
    		  const roofMat=new BABYLON.StandardMaterial("roofMat");
              roofMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg");
              const box = BABYLON.MeshBuilder.CreateBox("box",{} ); 
              box.position.y=0.5;
    		  box.material = boxMat;
    		  box.checkCollisions=true;
    		  const roof = BABYLON.MeshBuilder.CreateCylinder("roof", {diameter: 1.3, height: 1.2, tessellation: 3});
    		  roof.material = roofMat;
    		  roof.scaling.x = 0.75;
              roof.rotation.z = Math.PI / 2;
              roof.position.y = 1.22;
              const box2=BABYLON.MeshBuilder.CreateBox("box2",{});
    		  box2.position.x=5;
              box2.position.y=0.5;
              box2.material=boxMat;
    		  box2.checkCollisions=true;
              const roof2 = BABYLON.MeshBuilder.CreateCylinder("roof2", {diameter: 1.3, height: 1.2, tessellation: 3});
    		  roof2.material = roofMat;
    		  roof2.position.x=5;
    		  roof2.rotation.z = Math.PI / 2;
    		  roof2.position.y = 1.22;
    		  const box3=BABYLON.MeshBuilder.CreateBox("box3",{});
    		  box3.position.x=10;
              box3.position.y=0.5;
              box3.material=boxMat;
    		  box3.checkCollisions=true;
    		  const roof3 = BABYLON.MeshBuilder.CreateCylinder("roof3", {diameter: 1.3, height: 1.2, tessellation: 3});
    		  roof3.material = roofMat;
    		  roof3.position.x=10;
    		  roof3.rotation.z = Math.PI / 2;
    		  roof3.position.y = 1.22;
    		  const cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", {});
    		  cylinder.position.y=1;
    		  cylinder.position.z=5;
    		  cylinder.checkCollisions=true;
    		  cylinder.material=boxMat;
    		  const cylinder2 = BABYLON.MeshBuilder.CreateCylinder("cylinder2", {});
    		  cylinder2.position.y=1;
    		  cylinder2.position.z=5;
    		  cylinder2.position.x=5;
    		  cylinder2.checkCollisions=true;
    		  cylinder2.material=boxMat;
    		  const cylinder3 = BABYLON.MeshBuilder.CreateCylinder("cylinder3", {});
    		  cylinder3.position.y=1;
    		  cylinder3.position.z=5;
    		  cylinder3.position.x=10;

    		  cylinder3.checkCollisions=true;
    		  cylinder3.material=boxMat;
    		  const options = {
			 		sideOrientation: BABYLON.Mesh.DOUBLESIDE,
			 		width: 1,
			  		height: 1.5,
			  		depth: 2.8,
			  		tileSize: 1,
			  		tileWidth:3 }
			  const tiledBox = BABYLON.MeshBuilder.CreateTiledBox("", options);
			  tiledBox.material = mat;
    		  tiledBox.position.y=0.7;
    		  tiledBox.position.x=2;
    		  tiledBox.position.z=-3;
    		  tiledBox.checkCollisions=true;
    		  const tiledBox2 = BABYLON.MeshBuilder.CreateTiledBox("", options);
			  tiledBox2.material = mat;
			  tiledBox2.position.y=0.7;
    		  tiledBox2.position.x=8;
    		  tiledBox2.position.z=-3;
    		  tiledBox2.checkCollisions=true;
    		  const tiledBox3 = BABYLON.MeshBuilder.CreateTiledBox("", options);
			  tiledBox3.material = mat;
	   		  tiledBox3.position.y=0.7;
    		  tiledBox3.position.x=13;
    		  tiledBox3.position.z=-3;
    		  tiledBox3.checkCollisions=true;
              var camera1 = new BABYLON.ArcRotateCamera("camera1", Math.PI / 2, Math.PI / 4, 10, new BABYLON.Vector3(1, 1, 20), scene);
    		  scene.activeCamera = camera1;
    		  scene.activeCamera.attachControl(canvas, true);
    		  camera1.lowerRadiusLimit = 2;
    		  camera1.upperRadiusLimit = 10;
    		  camera1.wheelDeltaPercentage = 0.01;
    		  var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    		  var instructions = new BABYLON.GUI.TextBlock();
    		  instructions.text = "Move w/ WASD keys, B for Samba, look with the mouse";
    		  instructions.color = "white";
    		  instructions.fontSize = 16;
    		  instructions.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
    		  instructions.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    		  advancedTexture.addControl(instructions);
    		  var ground = BABYLON.MeshBuilder.CreateGround("ground", { height: 50, width: 50, subdivisions: 4 }, scene);
    		  var groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
    		  groundMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
    		  ground.material = groundMaterial;
    		  var inputMap = {};
      		  scene.actionManager = new BABYLON.ActionManager(scene);
    		  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
         	  inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";}));
    		  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
        	  inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";}));
        	  scene.collisionsEnabled = true;
        	  camera1.checkCollisions = true;
    		  BABYLON.SceneLoader.ImportMesh("", "https://assets.babylonjs.com/meshes/", "HVGirl.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
        	  var hero = newMeshes[0];   
        	  hero.position.x=1;    
       		  hero.scaling.scaleInPlace(0.1);
        	  camera1.target = hero;
        	  var heroSpeed = 0.03;
        	  var heroSpeedBackwards = 0.01;
        	  var heroRotationSpeed = 0.1;
         	  hero.ellipsoid = new BABYLON.Vector3(0.5, 1.0, 0.5);
			  hero.ellipsoidOffset = new BABYLON.Vector3(0, 1.0, 0);
			  hero.checkCollisions = true;
			  hero.applyGravity = true;
        	  var animating = true;
        	  const walkAnim = scene.getAnimationGroupByName("Walking");
        	  const walkBackAnim = scene.getAnimationGroupByName("WalkingBack");
         	  const idleAnim = scene.getAnimationGroupByName("Idle");
        	  const sambaAnim = scene.getAnimationGroupByName("Samba");
        	  scene.onBeforeRenderObservable.add(() => {
            		var keydown = false;
            		if (inputMap["w"]) {
                		hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                		keydown = true;
            		}
            		if (inputMap["s"]) {
                		hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
                		keydown = true;
            		}
            		if (inputMap["a"]) {
                		hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
                		keydown = true;
            		}
            		if (inputMap["d"]) {
                		hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
                		keydown = true;
            		}
            		if (inputMap["b"]) {
                		keydown = true;
            		}
            		if (keydown) {
                		if (!animating) {
                    		animating = true;
                    	if (inputMap["s"]) {
                        	walkBackAnim.start(true, 1.0, walkBackAnim.from, walkBackAnim.to, false);
                    	}
                    	else if (inputMap["b"]) {
                        	sambaAnim.start(true, 1.0, sambaAnim.from, sambaAnim.to, false);
                    	}
                    	else {
                       		walkAnim.start(true, 1.0, walkAnim.from, walkAnim.to, false);
                    	}
                	}
            	}
            	else {

                		if (animating) {
                        	idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);   
                    		sambaAnim.stop();
                    		walkAnim.stop();
                    		walkBackAnim.stop();
                    		animating = false;
                		}
            		}
        });
    });


   
              
              return scene;
          }
          var scene = createScene();
          engine.runRenderLoop(function(){
              scene.render();
          });
      });
  </script>
	
	
</head>
<body>
	<canvas id="canvas">
		
	</canvas>
	


</body>
</html>